## 탐험 여행은 URL 입력부터 시작한다

### URL은 여러 종류가 있다

> [http://user:password@www.cyber.co.kr:80/dir/file1.htm](http://user:password@www.cyber.co.kr:80/dir/file1.htm)  
> HTTP 프로토콜로 웹 서버에 액세스하는 경우

> [ftp://user:password@ftp.cy](ftp://user:password@ftp.cy)
> FTP 프로토콜로 파일을 다운로드하거나 업로드하는 경우

### 브라우저는 먼저 URL을 해독한다

[http://www.cyber.co.kr/dir/file1.htm](http://www.cyber.co.kr/dir/file1.htm)

http: : 프로토콜  
// : 나중에 이어지는 문자열이 서버의 이름을 나타낸다  
[www.cyber.co.kr](http://www.cyber.co.kr) : 웹 서버 명  
/dir/... : 데이터 출처의 경로를 나타낸다

### 파일명을 생략한 경우

[http://www.cyber.co.kr/dir/](http://www.cyber.co.kr/dir/)  
위의 URL에서 볼 수 있듯이 /dir/뒤의 파일명을 생략할 경우 미리 서버측에서 설정할 수 있다.  
서버가 `index.html`을 설정할 경우 `/dir/index.html`이라는 파일에 액세스 한다.

### HTTP의 기본 개념

![image](https://user-images.githubusercontent.com/18614517/58032145-ed4d8900-7b5c-11e9-8e38-cbf501eafb9e.png)

클라이언트는 서버에 요청을 보낼때 **메소드**로 어떤 동작을 하고 싶은지 전달한다.

주요 메서드 5가지

-   GET : 리소스 조회
-   POST : 요청 데이터 처리, 주로 데이터 등록에 사용
-   PUT : 리소스를 대체, 해당 리소스가 없으면 생성
-   PATCH : 리소스를 일부만 변경
-   DELETE : 리소스 삭제

기타 메소드 4가지

-   HEAD: GET과 거의 동일, 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
-   OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
-   CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
-   TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행

### HTTP 리퀘스트 메시지를 만든다, 리퀘스트 메시지를 보내면 응답이 되돌아 온다.

![http request](https://mdn.mozillademos.org/files/13827/HTTPMsgStructure2.png)

다음으로, 200번대는 성공의 의미를 뜻하는데 더 자세하게는 다음과 같다.

-   200 OK : 요청 성공
-   201 Created : 요청 성공해서 새로운 리소스가 생성됨
-   202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았음
-   204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음

300 번대는 리다이렉션인데 이는 location 헤더가 있으면 location 위치로 자동 이동하는 것을 리다이렉트라고 한다.

-   301 Moved Permanently : 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
-   302 Found : 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
-   303 See Other : 리다이렉트시 요청 메서드가 GET으로 변경
-   304 Not Modified : 캐시를 목적으로 사용
-   307 Temporary Redirect : 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다.)
-   308 Permanent Redirect : 리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST 유지)

400번대는 클라이언트 측에서 오류가 발생했다고 알려주는 것이다. 자세한 사항은 다음과 같다.

-   400 Bad Request : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
-   401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요함
-   403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함
-   404 Not Found : 요청 리소스를 찾을 수 없음

500번대는 서버 측에서 오류가 발생했다고 알려주는 것이다. 자세한 사항은 다음과 같다.

-   500 Internal Server Error : 서버 문제로 오류 발생, 애매하면 500 오류
-   503 Service Unavailable : 서비스 이용 불가

## 웹서버의 IP주소를 DNS서버에 조회한다.

### IP 주소의 기본

실제 IP주소는 32비트의 디지털 데이터로, 8비트씩 점으로 구분하여 10진수로 표기한다.

`10.11.12.13/255.255.255.0`  
`IP 주소 본체 / 넷마스크`

보통의 IP 주소 형태로는 어느 부분이 네트워크 번호인지 또는 호스트 번호인지 알 수 없다.  
IP주소의 규칙에서는 네트워크 번호와 호스트 번호의 두 가지를 합쳐서 32비트로 한다는 것만 결정되어 있을 뿐 내역은 결정되어있지 않다.  
따라서 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는 것, 이 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는데, 이 정보를 `넷마스크`라고 한다.  
  

![아이피 주소](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FO6RLp%2Fbtry2TM3lRl%2FRVKdJPvwdJU5pta8yWqDL1%2Fimg.png)

  
  

203.0.113 이 네트워크 번호 이고, 43이 호스트 번호이다.  
  

-   네트워크 번호의 비트를 1로 치환한 것이 해당 네트워크의 `넷마스크`이다.
-   호스트 번호 부분이 모드 0인 IP주소는 각각의 기기를 나타내는 것이 아니라 `서브넷 자체`를 나타낸다.
-   호스트번호 부분이 모두 1 즉 255이면 `브로드캐스트`를 나타낸다.

### 도메인명과 IP 주소를 구분하여 사용하는 이유

URL에 IP주소를 사용할 경우 올바르게 작동한다. 그러나 기억하기가 어렵다.  
<br>

주소를 도메인명으로 지정할 경우 IP주소는 32비트(4바이트)에 해당하는 갯수이지만, 도메인명은 수십바이트에서 255바이트까지의 문자를 취급해야 한다.  
<br>

그만큼 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸리면서 네트워크 속도가 느려진다.
<br>

이름을 알면 IP 주소를 알 수 있다거나 IP 주소를 알면 이름을 알 수 있다는 원리를 이용하여 양쪽의 차이를 해소한 것이 __DNS__이다.

### Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

DNS 서버에 조회한다는 것은 DNS 서버의 기준으로 클라이언트에 해당하는데  
클라이언트에 해당하는 것을 __DNS 리졸버 (리졸버)__라고 한다.
<br>

DNS의 원리를 사용하여 IP 주소를 조사하는 것을 __네임 리졸루션(name resolution)__이라 하고,  
이것을 실행 시키는것이 리졸버(resolver) 이다.
<br>

리졸버는 Socket 라이브러리 속에 들어있는 프로그램이다.

Soket 라이브러리

-   OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위해 부품을 모아놓은 것

### 리졸버를 이용하여 DNS 서버를 조회한다

리졸버의 프로그램명(gethostbyname)과 웹 서버 이름 www.cyber.co.kr을 사용하면 리졸버를 호출할 수 있다.

1.  도메인명에서 IP를 조사할 때 브라우저가 Socket 라이브러리의 리졸버를 호출
2.  리졸버가 DNS 서버에 조회 메시지를 보냄
3.  DNS 서버에서 응답메시지를 받음
4.  리졸버가 응답메시지에서 IP 주소를 추출하여 브라우저에서 지정한 메모리 영역에 등록

### 리졸버 내부의 작동

![resolver](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2Ff6f2a5f5-afea-4ea4-a971-dc62888ecbc5%2F483C5678-86AA-48F5-8BC6-6C2614720E3B.jpeg)

1.  웹 브라우저가 IP 주소 요청
2.  리졸버가 OS 내부 프로토콜 스택에 DNS 서버 전송 요청
3.  OS 내부 프로토콜 스택인 송신
4.  리졸버가 수신 후 IP 주소를 추출하여 웹 브라우저에게 전달
5.  IP 주소를 받은 웹 브라우저는 다음 명령을 실행

## 전 세계의 DNS 서버가 연대한다

### DNS 서버의 기본 동작

![dns server default work](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2Fba15250c-89c4-4af0-bc52-6031ebec84cc%2F0CC10194-311D-4A58-AD4E-727DA827F249.jpeg)

**DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP주소를 회답한다.**

조회 메시지에는 세 가지 정보가 포함되어 있다.

-   이름
    -   서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분 이름)
-   클래스
    -   인터넷 이외 네트워크를 고려하여 클래스 정보를 준비했으나, 인터넷만 사용하여 인터넷을 나타내는 'IN'값
-   타입
    -   이름에 어떤 타입(종류)의 정보가 지원되는지 나타낸다.
    -   A(Address) : IP주소가 지원됨
    -   MX : 메일 배송 목적지가 지원됨
    -   PTR  
        레코드(Reverse DNS) 은 도메인이 아닌 IP에 질의를 하여 도메인을 확인하는 과정으로, 수신측에서 메일 발송서버의 IP를 조회하여 도메인이 등록된 PTR  
        값과 일치하면 스팸으로 구분하지 않고 정상메일로 판단하겠다는 역방향의 질의 방식
    -   CNAME  
        타입에 따라 클라이언트에 회답하는 정보의 내용이 달라진다.

DNS 서버는 세 가지의 정보가 일치하는 것을 찾는다.  
타입이 MX일 경우에는 메일 서버의 우선 순위와 메일 서버의 이름이라는 두 항목이 들어있다.

-   복수의 메일 서버가 등록되어 있을 때 어느 메일 서버를 우선 선택해야 하는지 판단하기 위한 값  
    이름과 타입에 해당하는 것을 찾아 클라이언트에 회답하는것이 DNS 서버의 기본동작

### 도메인 계층

인터넷에는 막대한 수의 서버가 있으나 이것을 전부 1대의 DNS 서버에 등록하는 것은 불가능하다.
<br>

따라서 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지 찾아내는 구조이다.

DNS 서버에 등록한 정보에는 **도메인 명**이라는 계층적 구조를 가진 이름이 붙여져 있다.  
[www.lab.cyber.com](http://www.lab.cyber.com)  
점으로 계층을 구분한다.  
  

순차적으로  
com 사업부 cyber 부 lab 과의 www

![계층구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdRN2jJ%2Fbtry9nBULSM%2F8orRTGEVC6scP8PL881SIK%2Fimg.png)

도메인이 많아질 경우 하위 도메인을 만들면 된다.  
sub1.example.co.kr, sub2.example.co.kr  
하위도메인을 **서브 도메인**이라고 한다.

### 담장 DNS 서버를 찾아 IP 주소를 가져온다

수만개의 DNS 서버를 뒤질 수는 없다.

따라서 하위 도메인을 담당하는 DNS 서버의 IP 주소를 상위 DNS 서버에 등록 (반복)

![dns_search](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2Fc8bcbdda-8a41-4bc2-8df2-d87cbfeb9042%2F298ED4F9-15C3-4690-A054-FBA9FC562F3F.jpeg)

**루트 도메인**

루트 도메인에는 com이나 jp라는 도메인명이 없다. 따라서 생략한다.
<br>

루트 도메인의 DNS 서버를 인터넷에 존자해는 DNS 서버에 전부 등록해서 어느 DNS 서버도 루트 도메인에 엑세스가 가능하다.
<br>

루트 도메인의 DNS 서버에 할당된 IP 주소는 전 세계에 13개밖에 없고 좀처럼 변경되지 않는다.

-   루트 도메인 DNS는 복수의 서버 기계가 1대의 서버 기계에 보이는 형태로 운영되오 있으므로 IP 주소는 13개이지만 실제로는 다수의 서버 기계가 존재

### DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.

DNS 서버는 한번 조사한 이름을 캐시에 기록할 수 있다.

-   그 위치에서 계층 구조를 아래로 향하여 찾을 수 있다 루트 도메인 부터 찾기 시작하는 것보다 이 방법이 더 편리하다.

조회한 이름이 도메인에 등록되어 있지 않은 경우에는 이름이 존재하지 않는다는 회답이 돌아오지만, 이것을 캐시에 보존할 수 도 있다.  
<br>

캐시에 정보를 저장했을때 등록 정보가 변경될 경우 캐시에 저장되는 정보는 올바르다고 단언할 수 없다. 따라서 유효기간을 설정하고 지나면 캐시에서 삭제한다.  
<br>

또한 조회에 회답할때 정보가 캐시에 저장된 것인지, 아니면 등록처 DNS 서버에서 회답한 것인지 알려준다.

## 프로토콜 스택에 메시지 송신을 의뢰한다.

### 데이터 송/수신 동작의 개요

IP 주소를 조사했으면 웹 서버에 메시지를 송신하도록 OS의 내부에 있는 **프로토콜 스택**에 의뢰한다.

소켓(파이프라인)을 통해 서로 양방향 연결이됨

먼저 서버측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다린다.

파이프를 분리할 경우 어느쪽에서든 먼저 분리해도 상관없다.

-   실제로는 분리되는 순서를 애플리케이션 규칙으로 결정해 둔다.

1.  소켓을 만듬
2.  서버측의 소켓에 파이프를 연결함
3.  데이터를 송/수신함
4.  파이프를 분리하고 소켓을 말소함

### 소켓의 작성 단계

![소켓생성](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FE0hkA%2FbtqUM8vvcQc%2FrjRy5UayumkfW8g09oKTZ1%2Fimg.png)

소켓이 생기면 디스크럽터라는 것이 돌아오는데, 애플리케이션은 이것을 받아서 메모리에 기록한다.  
디스크럽터는 소켓을 식별하기 위해 사용한다.(2개의 브라우저 창을 열 경우 2개의 다른 웹 서버에 접속할 경우)

### 파이프를 연결하는 접속 단계

애플리케이션은 Socket 라이브러리의 connect라는 프로그램 부품을 호출하여 의뢰 동작을 실행합니다.

-   디스크럽터
-   서버의 IP 주소
-   포트 번호

포트번호로 접속 상대의 소켓을 지정할 수 있다.

URL에는 포트번호를 사용하지 않는경우

→ 미리 결정된 값을 사용한다는 규칙이 있다

웹 : 80 메일 25번

### 메시지를 주고받는 송/수신 단계

애플리케이션 송신 데이터를 메모리에 준비 → 사용자가 입력한 URL을 바탕으로 만든 HTTP 리퀘스트 메시지가 여기에서 말하는 송신데이터이다.

1.  write를 호출할 때 디스크립터와 송신 데이터를 지정.
2.  소켓에는 연결된 상대가 기록되어 있으므로 디스크럽터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신한다.
3.  서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송한다.

Socket의 read라는 프로그램 부품을 통해 프로토콜 스택에 수신동작을 의뢰한다  
  

수신한 응답 메시지를 저장하기 위한 메모리 영역을 지정하는데, 이 메모리 영역을 **수신 버퍼** 라고 부른다.
<br>

### 연결 끊기 단계에서 송/수신이 종료된다.

브라우저가 데이터 수신을 완료하면 송/수신 동작은 끝낸다.  
그후 Socket 라이브러리의 close라는 프로그램 부품을 호출하여 연결 끊기 단게로 들어가도록 의뢰 한다.  
-> 소켓 말소, 파이프라인 분리  
<br>

웹에서 사용하는 HTTP 프로토콜에서는 본래 응답 메시지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 실행한다.  
먼저 웹 서버측에서 close를 호출하여 연결을 끊는다.  
<br>

이것이 클라이언트측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.
<br>

브라우저가 read로 수신 동작을 의뢰했을 때 read는 수신한 데이터를 건네주는 대신 송/수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에 통지한다.
<br>

이로서 송/수신이 종료디었다는 것을 알 수 있으므로 브라우저에서도 close를 호출하여 연결 끊기 단계에 들어간다.
